do obliczania paraboli do simpsona: [
    import numpy as np

    # Define f(x)
    def f(x):
        return 0.8 * np.sin(x) + 0.5 * x

    # Points through which P_2(x) must pass
    x_points = np.array([1, 2.5, 4])
    y_points = np.array([f(1), f(2.5), f(4)])

    # Matrix for the system of equations
    A = np.vstack([x_points**2, x_points, np.ones(len(x_points))]).T

    # Solve for the coefficients
    coefficients = np.linalg.solve(A, y_points)

    # Coefficients of the polynomial
    a, b, c = coefficients

    print(f"The polynomial P_2(x) = {a}x^2 + {b}x + {c}")
]

string to equation:
[
    from sympy import sympify, simplify

    # Example expression
    expr_string = "x**2 + 3*x - 1/2 + acos(x)"

    # Parsing the string to a sympy expression
    expr = sympify(expr_string)

    # Display the parsed expression
    print(f"Parsed Expression: {expr}")

    # Evaluate the expression for a specific value of x
    x_value =0.23
    evaluated_expr = expr.subs('x', x_value)
    numeric_value = evaluated_expr.evalf()
    print(f"Evaluated at x={x_value}: {evaluated_expr}")
    print(f" x={x_value}: {numeric_value}")
]

error metoda pr:
import sympy as sp

def estimate_rectangular_method_error(a, b, n, f_expr):
    """
    Estimate the error of the Rectangular (Midpoint) Method for numerical integration.

    Parameters:
    - a: The lower limit of integration.
    - b: The upper limit of integration.
    - n: The number of subintervals (rectangles).
    - f_expr: A sympy expression representing the function f(x).

    Returns:
    - The estimated error of the Rectangular Method.
    """
    # Define the symbol
    x = sp.symbols('x')

    # Calculate the second derivative of the function
    f_second_derivative = sp.diff(f_expr, x, 2)

    # Find the maximum value of the second derivative in the interval [a, b]
    # Note: For simplicity, this example just evaluates the second derivative at the endpoints
    # and the midpoint. For a more accurate estimate, you could use optimization methods.
    f_second_derivative_max = max(f_second_derivative.subs(x, a),
                                  f_second_derivative.subs(x, b),
                                  f_second_derivative.subs(x, (a+b)/2))

    # Calculate the error estimate
    error_estimate = ((b - a)**3 / (24 * n**2)) * f_second_derivative_max

    return error_estimate

# Example usage
if __name__ == "__main__":
    # Define the function to integrate as a sympy expression
    f_expr = sp.sympify('x**2 + 2*x + 1')

    # Define the integration interval and number of subintervals
    a, b, n = 0, 10, 100

    # Estimate the error
    error_estimate = estimate_rectangular_method_error(a, b, n, f_expr)
    print(f"Estimated error: {error_estimate}")

x<sup>i</sup> - x**i lub x^i
&#960; = pi
arccos(x) = acos(x)
arcsin(x) = asin(x)
arctg(x) = atan(x)
arcctg(x) = acot(x)
2ร3 = 2*3
10รท5 = 10/5
|x-5| = abs(x-5)


